package parser;
import java_cup.runtime.*;

   
/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:
    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
            System.out.println("\n*** Resultados finales ***");
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }





:};


  
terminal IDENTIFIER, 
    BOOLEAN_OPERATOR, OPERATOR, ARITHMETICOP,
    RESERVED, 
    FLOATING_POINT_NUMERIC_LITERAL, INTEGER_NUMERIC_LITERAL, 
    SCIENTIFIC_NOTATION_NUMERIC_LITERAL,
    STRING_LITERAL, CHAR_LITERAL,NUMERIC_CHAR_LITERAL,
    OPEN_PARENTHESIS, CLOSE_PARENTHESIS,
    OTHER,
    MINUS_OP,
    //Reserved Words
    PROGRAM,
    ARRAY,
    BEGIN,
    BOOLEAN,
    CASE,
    CHAR,
    CONST,
    DO,
    ELSE,
    END,
    FALSE,
    FOR,
    FUNCTION,
    IF,
    INT,
    LONGINT,
    OF,
    PROCEDURE,
    READ,
    REPEAT,
    SHORTINT,
    STRING,
    THEN,
    TO,
    TRUE,
    UNTIL,
    VAR,
    WHILE,
    WRITE,

    EQUAL,
    LITERAL,
    SEMI,
    COMMA,
    MINUSOP,
    COLON,
    
    ERROR_COMMENT,
    ERROR_FLOATING_POINT,
    ERROR_IDENTIFIER,
    ERROR_INTEGER,
    ERROR_STRING,
    ERROR_INVALID_CHARACTER,
    ERROR_INVALID_LENGTH;


non terminal program,constants,constants_body,
            globals, globals_body, globals_list,
            Type,functions,function_header,
            parameter_list,function_body,
            statements,if_statement,cond,
            else_statement,while_statement,
            for_statement,exp,assignment,
            fun_call,read,write,
            exp2,cond2,statement;



program ::= PROGRAM IDENTIFIER constants globals functions BEGIN statements END;

constants ::= CONST constants_body;

constants_body ::= IDENTIFIER EQUAL LITERAL SEMI constants_body | 
                    IDENTIFIER EQUAL INTEGER_NUMERIC_LITERAL SEMI constants_body| 
                   IDENTIFIER EQUAL STRING_LITERAL SEMI constants_body |
                   IDENTIFIER EQUAL CHAR_LITERAL SEMI constants_body | 
                    IDENTIFIER EQUAL FLOATING_POINT_NUMERIC_LITERAL SEMI constants_body | 
                   IDENTIFIER EQUAL NUMERIC_CHAR_LITERAL SEMI constants_body |
                   IDENTIFIER EQUAL SCIENTIFIC_NOTATION_NUMERIC_LITERAL SEMI constants_body 
                    |  IDENTIFIER EQUAL error SEMI {: parser.report_error("Error al declarar una constante", null); :};
                    | /*epsilon*/;

globals ::= VAR globals_body;

globals_body ::= IDENTIFIER globals_list COLON Type SEMI | 
                 IDENTIFIER globals_list COLON error SEMI {: parser.report_error("Tipo no existe", null); :} ;

globals_list ::= COMMA IDENTIFIER globals_list | /*epsilon*/;

Type ::= INT|CHAR|STRING;

functions ::= FUNCTION function_header | PROCEDURE function_header | /*epsilon*/;

function_header ::= IDENTIFIER OPEN_PARENTHESIS Type IDENTIFIER parameter_list CLOSE_PARENTHESIS :Type BEGIN function_body END 
                   | IDENTIFIER OPEN_PARENTHESIS Type IDENTIFIER error CLOSE_PARENTHESIS :Type BEGIN function_body END{:
                                                               : parser.report_error("La func", null); 
                                                               :}; 

parameter_list ::= COMMA Type IDENTIFIER parameter_list | /*epsilon*/;

function_body ::= constants globals statements assignment;



statements ::= statement SEMI statements | /*epsilon*/;

statement ::= if_statement|while_statement|
                for_statement|assignment|fun_call|
                read|write|/*epsilon*/;


if_statement ::= IF OPEN_PARENTHESIS cond CLOSE_PARENTHESIS THEN statements else_statement END 
                | IF OPEN_PARENTHESIS error CLOSE_PARENTHESIS THEN statements else_statement END {:
                                                               : parser.report_error("Error en la condicion", null); 
                                                               :}; 
                                                            

cond ::= IDENTIFIER | OPEN_PARENTHESIS cond CLOSE_PARENTHESIS | 
        TRUE | FALSE 
         |fun_call; 

/*cond ::= IDENTIFIER cond2| OPEN_PARENTHESIS cond CLOSE_PARENTHESIS cond2| 
        TRUE cond2| FALSE cond2
         |fun_call cond2; 

cond2 ::= BOOLEAN_OPERATOR cond cond2;*/
         

else_statement ::= ELSE statements | /*epsilon*/; 

while_statement ::= WHILE cond DO BEGIN statements END | WHILE error DO BEGIN statements END{:
                                                               : parser.report_error("Error en la condicion", null); 
                                                               :};

for_statement ::= FOR IDENTIFIER :EQUAL exp TO exp DO BEGIN statements END | 
                  FOR error TO exp DO BEGIN statements END {: parser.report_error("Debe de asignar un valor", null); :};

exp ::= IDENTIFIER exp2| OPEN_PARENTHESIS exp CLOSE_PARENTHESIS exp2| TRUE exp2| FALSE exp2|  
        FLOATING_POINT_NUMERIC_LITERAL exp2| 
        INTEGER_NUMERIC_LITERAL exp2| SCIENTIFIC_NOTATION_NUMERIC_LITERAL exp2| 
        STRING_LITERAL exp2| NUMERIC_CHAR_LITERAL exp2| 
        CHAR_LITERAL exp2| fun_call exp2| MINUSOP exp exp2;

exp2 ::= BOOLEAN_OPERATOR exp exp2 | ARITHMETICOP exp exp2;

assignment ::= IDENTIFIER COLON EQUAL exp | IDENTIFIER COLON EQUAL error SEMI {:
                                                               : parser.report_error("Error en la asignacion", null); 
                                                               :};

fun_call ::= IDENTIFIER OPEN_PARENTHESIS Type IDENTIFIER parameter_list CLOSE_PARENTHESIS statements|IDENTIFIER OPEN_PARENTHESIS CLOSE_PARENTHESIS;

read ::= READ OPEN_PARENTHESIS Type IDENTIFIER CLOSE_PARENTHESIS statements|READ OPEN_PARENTHESIS CLOSE_PARENTHESIS;

write ::= WRITE OPEN_PARENTHESIS Type IDENTIFIER parameter_list CLOSE_PARENTHESIS;






